{"ast":null,"code":"import { useMemo, useRef, useCallback, useEffect } from 'react';\nimport lodashDebounce from 'lodash.debounce';\n\nvar createCallback = function createCallback(debounce, handleOnScroll, options) {\n  if (debounce) {\n    return lodashDebounce(handleOnScroll, debounce, options);\n  } else {\n    return handleOnScroll;\n  }\n};\n\nfunction useBottomScrollListener(onBottom, offset, debounce, debounceOptions, triggerOnNoScroll) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (debounce === void 0) {\n    debounce = 200;\n  }\n\n  if (debounceOptions === void 0) {\n    debounceOptions = {\n      leading: true\n    };\n  }\n\n  if (triggerOnNoScroll === void 0) {\n    triggerOnNoScroll = false;\n  }\n\n  var debouncedOnBottom = useMemo(function () {\n    return createCallback(debounce, onBottom, debounceOptions);\n  }, [debounce, onBottom]);\n  var containerRef = useRef(null);\n  var handleOnScroll = useCallback(function () {\n    if (containerRef.current != null) {\n      var scrollNode = containerRef.current;\n      var scrollContainerBottomPosition = Math.round(scrollNode.scrollTop + scrollNode.clientHeight);\n      var scrollPosition = Math.round(scrollNode.scrollHeight - offset);\n\n      if (scrollPosition <= scrollContainerBottomPosition) {\n        debouncedOnBottom();\n      }\n    } else {\n      var _scrollNode = document.scrollingElement || document.documentElement;\n\n      var _scrollContainerBottomPosition = Math.round(_scrollNode.scrollTop + window.innerHeight);\n\n      var _scrollPosition = Math.round(_scrollNode.scrollHeight - offset);\n\n      if (_scrollPosition <= _scrollContainerBottomPosition) {\n        debouncedOnBottom();\n      }\n    }\n  }, [offset, onBottom, containerRef.current]);\n  useEffect(function () {\n    var ref = containerRef.current;\n\n    if (ref != null) {\n      ref.addEventListener('scroll', handleOnScroll);\n    } else {\n      window.addEventListener('scroll', handleOnScroll);\n    }\n\n    if (triggerOnNoScroll) {\n      handleOnScroll();\n    }\n\n    return function () {\n      if (ref != null) {\n        ref.removeEventListener('scroll', handleOnScroll);\n      } else {\n        window.removeEventListener('scroll', handleOnScroll);\n      }\n    };\n  }, [handleOnScroll, debounce]);\n  return containerRef;\n}\n\nvar BottomScrollListener = function BottomScrollListener(_ref) {\n  var children = _ref.children,\n      onBottom = _ref.onBottom,\n      offset = _ref.offset,\n      debounce = _ref.debounce,\n      debounceOptions = _ref.debounceOptions,\n      triggerOnNoScroll = _ref.triggerOnNoScroll;\n  var optionalScrollContainerRef = useBottomScrollListener(onBottom, offset, debounce, debounceOptions, triggerOnNoScroll);\n  if (!children) return null;else if (typeof children === 'function') return children(optionalScrollContainerRef);else return children;\n};\n\nexport default BottomScrollListener;\nexport { useBottomScrollListener };","map":{"version":3,"sources":["../src/hook/index.tsx","../src/component/index.tsx"],"names":["createCallback","lodashDebounce","offset","debounce","debounceOptions","leading","triggerOnNoScroll","debouncedOnBottom","useMemo","containerRef","useRef","handleOnScroll","useCallback","scrollNode","scrollContainerBottomPosition","Math","scrollPosition","document","window","useEffect","ref","BottomScrollListener","children","onBottom","optionalScrollContainerRef","useBottomScrollListener"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef, useMemo } from 'react'\nimport lodashDebounce from 'lodash.debounce'\n\nexport type DebounceOptions = Parameters<typeof lodashDebounce>[2]\n\nconst createCallback = (debounce: number, handleOnScroll: () => void, options: DebounceOptions): (() => void) => {\n  if (debounce) {\n    return lodashDebounce(handleOnScroll, debounce, options)\n  } else {\n    return handleOnScroll\n  }\n}\n\n/**\n *  A react hook that invokes a callback when user scrolls to the bottom\n *\n * @param onBottom Required callback that will be invoked when scrolled to bottom\n * @param offset Offset from bottom of page in pixels. E.g. 300 will trigger onBottom 300px from the bottom of the page\n * @param debounce Optional debounce in milliseconds, defaults to 200ms\n * @param debounceOptions Options passed to lodash.debounce, see https://lodash.com/docs/4.17.15#debounce\n * @param triggerOnNoScroll Triggers the onBottom callback when the page has no scrollbar\n * @return React.MutableRefObject Optionally you can use this to pass to a element to use that as the scroll container\n */\nfunction useBottomScrollListener<T extends HTMLElement>(\n  onBottom: () => void,\n  offset: number = 0,\n  debounce: number = 200,\n  debounceOptions: DebounceOptions = { leading: true },\n  triggerOnNoScroll: boolean = false\n) {\n  const debouncedOnBottom = useMemo(() => createCallback(debounce, onBottom, debounceOptions), [debounce, onBottom])\n  const containerRef = useRef<T>(null)\n  const handleOnScroll = useCallback(() => {\n    if (containerRef.current != null) {\n      const scrollNode: T = containerRef.current\n      const scrollContainerBottomPosition = Math.round(scrollNode.scrollTop + scrollNode.clientHeight)\n      const scrollPosition = Math.round(scrollNode.scrollHeight - offset)\n\n      if (scrollPosition <= scrollContainerBottomPosition) {\n        debouncedOnBottom()\n      }\n    } else {\n      const scrollNode: Element = document.scrollingElement || document.documentElement\n      const scrollContainerBottomPosition = Math.round(scrollNode.scrollTop + window.innerHeight)\n      const scrollPosition = Math.round(scrollNode.scrollHeight - offset)\n\n      if (scrollPosition <= scrollContainerBottomPosition) {\n        debouncedOnBottom()\n      }\n    }\n    // ref dependency needed for the tests, doesn't matter for normal execution\n  }, [offset, onBottom, containerRef.current])\n\n  useEffect((): (() => void) => {\n    const ref: T | null = containerRef.current\n    if (ref != null) {\n      ref.addEventListener('scroll', handleOnScroll)\n    } else {\n      window.addEventListener('scroll', handleOnScroll)\n    }\n\n    if (triggerOnNoScroll) {\n      handleOnScroll()\n    }\n\n    return () => {\n      if (ref != null) {\n        ref.removeEventListener('scroll', handleOnScroll)\n      } else {\n        window.removeEventListener('scroll', handleOnScroll)\n      }\n    }\n  }, [handleOnScroll, debounce])\n\n  return containerRef\n}\n\nexport default useBottomScrollListener\n","import React from 'react'\n\nimport useBottomScrollListener, { DebounceOptions } from '../hook'\n\nexport interface Props {\n  /**\n   * Required callback that will be invoked when scrolled to bottom\n   */\n  onBottom: () => void\n\n  /**\n   * Offset from bottom of page in pixels. E.g. 300 will trigger onBottom 300px from the bottom of the page\n   */\n  offset?: number\n\n  /**\n   * Optional debounce in milliseconds, defaults to 200ms\n   */\n  debounce?: number\n\n  /**\n   * Options passed to lodash.debounce, see https://lodash.com/docs/4.17.15#debounce\n   */\n  debounceOptions?: DebounceOptions\n\n  /**\n   * Triggers the onBottom callback when the page has no scrollbar, defaults to false\n   */\n  triggerOnNoScroll?: boolean\n\n  /**\n   *   Optional children to be rendered.\n   *\n   *   If children passed is a function, that function will be passed a React.RefObject<HTMLElement>\n   *   that ref shall be passed to a child tag that will be used for the scrolling container.\n   * */\n  children?:\n    | JSX.Element\n    | (<T>(ref: ((instance: T | null) => void) | React.MutableRefObject<T | null> | null) => JSX.Element)\n}\n\n/**\n * A simple React component that lets you listen for when you have scrolled to the bottom.\n */\nconst BottomScrollListener = ({ children, onBottom, offset, debounce, debounceOptions, triggerOnNoScroll }: Props): JSX.Element | null => {\n  const optionalScrollContainerRef = useBottomScrollListener(onBottom, offset, debounce, debounceOptions, triggerOnNoScroll)\n\n  if (!children) return null\n  else if (typeof children === 'function') return children(optionalScrollContainerRef)\n  else return children\n}\n\nexport default BottomScrollListener\n"]},"metadata":{},"sourceType":"module"}